apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-scripts
  labels:
    app: ai-knowledge-hub
    release: {{ .Release.Name }}
data:
  package.json: |
    {
      "name": "ai-knowledge-hub-scripts",
      "version": "1.0.0",
      "type": "module",
      "dependencies": {
        "ioredis": "^5.3.2",
        "chokidar": "^3.5.3",
        "glob": "^10.3.10",
        "@modelcontextprotocol/sdk": "^0.6.0",
        "zod": "^3.22.4",
        "@google/generative-ai": "^0.1.3",
        "tsx": "^4.7.1",
        "express": "^4.18.2",
        "cors": "^2.8.5",
        "body-parser": "^1.20.2",
        "@types/express": "^4.17.21",
        "@types/cors": "^2.8.17",
        "@types/body-parser": "^1.19.5"
      }
    }

  watcher.ts: |
    import Redis from 'ioredis';
    import * as chokidar from 'chokidar';
    import * as fs from 'fs';
    import * as path from 'path';

    import { GoogleGenerativeAI } from "@google/generative-ai";

    // Configuration from environment or default
    const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
    const PROJECTS_CONFIG = process.env.PROJECTS_CONFIG ? JSON.parse(process.env.PROJECTS_CONFIG) : [];
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

    if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is required");
      process.exit(1);
    }

    const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
    const model = genAI.getGenerativeModel({ model: "text-embedding-004" });

    console.log('Starting Ingestion Watcher...');
    console.log('Redis URL:', REDIS_URL);
    console.log('Projects to watch:', PROJECTS_CONFIG);

    const redisClient = new Redis(REDIS_URL);

    redisClient.on('error', (err) => console.error('Redis Client Error', err));

    // Simple Promise Queue for rate limiting
    class PromiseQueue {
      private queue: (() => Promise<void>)[] = [];
      private active = 0;
      private limit: number;

      constructor(limit: number) {
        this.limit = limit;
      }

      add(fn: () => Promise<void>) {
        this.queue.push(fn);
        this.next();
      }

      private next() {
        if (this.active >= this.limit || this.queue.length === 0) return;
        this.active++;
        const fn = this.queue.shift();
        if (fn) {
          fn().finally(() => {
            this.active--;
            this.next();
          });
        }
      }
    }

    // Limit to 3 concurrent requests to avoid Gemini rate limits during initial scan
    const queue = new PromiseQueue(3);

    async function connectRedis() {
      // ioredis connects automatically, but we can wait for ready
      // await redisClient.connect(); // Not needed for ioredis
      console.log('Connected to Redis');
      
      try {
        // FT.CREATE idx:knowledge ON JSON PREFIX 1 doc: SCHEMA $.content AS content TEXT $.project AS project TAG $.path AS path TAG $.embedding AS embedding VECTOR FLAT 6 TYPE FLOAT32 DIM 768 DISTANCE_METRIC COSINE
        await redisClient.call('FT.CREATE', 'idx:knowledge', 
          'ON', 'JSON', 
          'PREFIX', '1', 'doc:', 
          'SCHEMA', 
          '$.content', 'AS', 'content', 'TEXT',
          '$.project', 'AS', 'project', 'TAG',
          '$.path', 'AS', 'path', 'TAG',
          '$.embedding', 'AS', 'embedding', 'VECTOR', 'FLAT', '6', 'TYPE', 'FLOAT32', 'DIM', '768', 'DISTANCE_METRIC', 'COSINE'
        );
        console.log('Index idx:knowledge created');
      } catch (e: any) {
        if (e.message.includes('Index already exists')) {
          console.log('Index idx:knowledge already exists');
        } else {
          console.error('Error creating index:', e);
        }
      }
    }

    // Generate embedding using Gemini
    async function generateEmbedding(text: string): Promise<number[]> {
      try {
        // Add a small delay to further space out requests if needed
        await new Promise(resolve => setTimeout(resolve, 500));
        const result = await model.embedContent(text);
        const embedding = result.embedding;
        return embedding.values;
      } catch (error) {
        console.error("Error generating embedding:", error);
        return [];
      }
    }

    // Chunking configuration
    const CHUNK_SIZE = 1000;
    const CHUNK_OVERLAP = 100;

    function chunkText(text: string, maxLength: number, overlap: number): string[] {
      const chunks: string[] = [];
      let startIndex = 0;

      while (startIndex < text.length) {
        let endIndex = startIndex + maxLength;
        
        if (endIndex < text.length) {
            // Try to break at newline first
            let breakPoint = text.lastIndexOf('\n', endIndex);
            // If no newline in the last 20% of the chunk, try space
            if (breakPoint === -1 || breakPoint < endIndex - (maxLength * 0.2)) {
                breakPoint = text.lastIndexOf(' ', endIndex);
            }
            
            if (breakPoint !== -1 && breakPoint > startIndex) {
                endIndex = breakPoint + 1;
            }
        }

        const chunk = text.slice(startIndex, endIndex).trim();
        if (chunk.length > 0) {
            chunks.push(chunk);
        }

        // Move start index for next chunk, accounting for overlap
        // If we reached the end, we are done
        if (endIndex >= text.length) break;
        
        startIndex = endIndex - overlap;
        // Safety check to ensure progress
        if (startIndex < 0) startIndex = 0;
      }
      
      return chunks;
    }

    async function processFile(filePath: string, project: any) {
      if (!filePath.endsWith('.md')) return;

      queue.add(async () => {
        try {
          const content = fs.readFileSync(filePath, 'utf-8');
          const relativePath = path.relative(project.path, filePath);
          // Base key pattern for this file's chunks
          const baseKey = `doc:${project.redis_prefix}:${relativePath}`;

          console.log(`Processing file: ${filePath}`);

          // 1. Cleanup existing chunks for this file
          // We search for keys starting with the baseKey + ":chunk_"
          const existingKeys = await redisClient.keys(`${baseKey}:chunk_*`);
          if (existingKeys.length > 0) {
              await redisClient.del(...existingKeys);
              console.log(`Deleted ${existingKeys.length} old chunks for ${relativePath}`);
          }

          // 2. Chunk the content
          const chunks = chunkText(content, CHUNK_SIZE, CHUNK_OVERLAP);
          console.log(`Split ${relativePath} into ${chunks.length} chunks`);

          // 3. Process each chunk
          for (let i = 0; i < chunks.length; i++) {
              const chunkContent = chunks[i];
              const chunkKey = `${baseKey}:chunk_${i}`;
              
              const embedding = await generateEmbedding(chunkContent);

              if (embedding.length === 0) {
                  console.warn(`Skipping chunk ${i} of ${filePath} due to empty embedding`);
                  continue;
              }

              const doc = {
                content: chunkContent,
                path: relativePath,
                project: project.name,
                embedding: embedding,
                chunk_index: i,
                total_chunks: chunks.length,
                updatedAt: new Date().toISOString()
              };
              
              await redisClient.call('JSON.SET', chunkKey, '$', JSON.stringify(doc));
              console.log(`Saved chunk ${i}/${chunks.length} to Redis: ${chunkKey}`);
          }

        } catch (error) {
          console.error(`Error processing file ${filePath}:`, error);
        }
      });
    }

    async function startWatcher() {
      await connectRedis();

      PROJECTS_CONFIG.forEach((project: any) => {
        console.log(`Watching ${project.path} for project ${project.name}`);
        
        chokidar.watch(project.path, {
          ignored: /(^|[\/\\])\../, // ignore dotfiles
          persistent: true,
          ignoreInitial: false // Explicitly state we want initial scan
        }).on('add', path => processFile(path, project))
          .on('change', path => processFile(path, project))
          .on('ready', () => console.log(`Initial scan complete for ${project.name}`));
      });
    }

    startWatcher();

  mcp-server.ts: |
    import { Server } from "@modelcontextprotocol/sdk/server/index.js";
    import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
    import {
      CallToolRequestSchema,
      ListToolsRequestSchema,
    } from "@modelcontextprotocol/sdk/types.js";
    import { z } from "zod";
    import Redis from 'ioredis';
    import { GoogleGenerativeAI } from "@google/generative-ai";
    import express from "express";
    import cors from "cors";
    import bodyParser from "body-parser";

    const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
    const PORT = process.env.PORT || 3000;

    if (!GEMINI_API_KEY) {
      console.error("GEMINI_API_KEY is required");
      process.exit(1);
    }

    const redisClient = new Redis(REDIS_URL);
    const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
    const model = genAI.getGenerativeModel({ model: "text-embedding-004" });

    redisClient.on('error', (err) => console.error('Redis Client Error', err));

    const app = express();
    app.use(cors());
    app.use(bodyParser.json());

    // Store active transports to handle incoming messages
    const transports = new Map<string, SSEServerTransport>();


    // Helper function for search logic - defined globally
    async function executeSearch(query: string, project_id?: string) {
        try {
            const embedding = await generateEmbedding(query);
            const blob = Buffer.from(new Float32Array(embedding).buffer);
            let filter = '*';
            if (project_id) {
                filter = `@project:{${project_id}}`;
            }
            const args = [
                'idx:knowledge',
                `${filter}=>[KNN 3 @embedding $vec AS score]`,
                'PARAMS', '2', 'vec', blob,
                'DIALECT', '2',
                'RETURN', '4', 'content', 'path', 'project', 'score',
                'SORTBY', 'score'
            ];
            const response = await redisClient.call('FT.SEARCH', ...args) as any[];
            const total = response[0];
            const results = [];
            for (let i = 1; i < response.length; i += 2) {
                const key = response[i];
                const fields = response[i+1]; 
                const doc: any = {};
                for (let j = 0; j < fields.length; j += 2) {
                    doc[fields[j]] = fields[j+1];
                }
                results.push(doc);
            }
            return { total, results };
        } catch (error) {
            throw error;
        }
    }

    // Debug endpoint for stress testing - defined globally
    app.post("/debug/search", async (req, res) => {
        try {
            const { query, project_id } = req.body;
            if (!query) {
                res.status(400).json({ error: "Query is required" });
                return;
            }
            const result = await executeSearch(query, project_id);
            res.json(result);
        } catch (error: any) {
            console.error("Debug search error:", error);
            res.status(500).json({ error: error.message });
        }
    });

    function createServer() {
      const server = new Server(
        {
          name: "ai-knowledge-hub",
          version: "1.0.0",
        },
        {
          capabilities: {
            tools: {},
          },
        }
      );

      server.setRequestHandler(ListToolsRequestSchema, async () => {
        return {
          tools: [
            {
              name: "search_knowledge_base",
              description: "Search the AI Knowledge Hub for relevant documentation and code snippets using vector search.",
              inputSchema: {
                type: "object",
                properties: {
                  query: {
                    type: "string",
                    description: "The search query (e.g., 'how to install', 'project architecture')",
                  },
                  project_id: {
                    type: "string",
                    description: "Optional project ID to filter results (e.g., 'elisabete-nogueira')",
                  },
                },
                required: ["query"],
              },
            },
          ],
        };
      });

      server.setRequestHandler(CallToolRequestSchema, async (request) => {
        if (request.params.name === "search_knowledge_base") {
          const { query, project_id } = request.params.arguments as any;
          
          try {
              const { total, results } = await executeSearch(query, project_id);
              
              if (results.length === 0) {
                   return {
                      content: [{ type: "text", text: `No relevant documents found for "${query}".` }],
                  };
              }

              const formattedResults = results.map((doc: any) => {
                  return `[${doc.project}] ${doc.path} (Score: ${doc.score})\n---\n${doc.content}\n---`;
              }).join('\n\n');

              return {
                content: [{ type: "text", text: `Found ${total} documents for "${query}":\n\n${formattedResults}` }],
              };
          } catch (error: any) {
              console.error("Search error:", error);
              return {
                  content: [{ type: "text", text: `Error performing search: ${error.message}` }],
                  isError: true,
              };
          }
        }
        throw new Error("Tool not found");
      });

      return server;
    }

    async function generateEmbedding(text: string): Promise<number[]> {
        const result = await model.embedContent(text);
        return result.embedding.values;
    }

    app.get("/sse", async (req, res) => {
      console.log("New SSE connection established");
      const transport = new SSEServerTransport("/messages", res);
      const server = createServer();
      
      await server.connect(transport);

      // The transport.sessionId is generated by the SDK
      const sessionId = (transport as any).sessionId;
      if (sessionId) {
          transports.set(sessionId, transport);
      }

      req.on("close", () => {
          console.log("SSE connection closed");
          if (sessionId) transports.delete(sessionId);
          server.close();
      });
    });

    app.post("/messages", async (req, res) => {
      const sessionId = req.query.sessionId as string;
      const transport = transports.get(sessionId);

      if (!transport) {
          console.warn(`Session not found: ${sessionId}`);
          res.status(404).send("Session not found");
          return;
      }

      await transport.handlePostMessage(req, res);
    });

    app.get("/health", (req, res) => {
      res.status(200).send("OK");
    });

    app.listen(PORT, () => {
      console.log(`AI Knowledge Hub MCP Server running on port ${PORT}`);
    }).on('error', (error) => {
      console.error("Server error:", error);
      process.exit(1);
    });
